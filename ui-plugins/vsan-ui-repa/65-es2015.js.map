{"version":3,"sources":["./node_modules/ipaddr.js/lib/ipaddr.js","./src/app/vsan/common/service/ip-parser.service.ts"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;;AAEA;;AAEA;;AAEA,OAAO,KAA6B;AACpC;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,yBAAyB,GAAG;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,EAAE;AACnE;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;;AC7mBD;AAAA;AAAA;AAAA;AAA4C;AAE5C;;;;GAIG;AAEI;UAAM,eAAe;QAD5B;YAiBG,uBAAkB,GAAG,CAAC,SAAiB,EAAE,EAAE;gBACxC,MAAM,SAAS,GAAW,SAAS,CAAC,IAAI,EAAE,CAAC;gBAC3C,OAAO,8CAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;YACtE,CAAC,CAAC;YAEF,uBAAkB,GAAG,CAAC,SAAiB,EAAE,eAAe,GAAY,KAAK,EAAW,EAAE;gBACnF,IAAI,CAAC,SAAS,EAAE;oBACb,OAAO,KAAK,CAAC;iBACf;gBAED,IAAI,IAAI,GAAW,SAAS,CAAC,IAAI,EAAE,CAAC;gBAEpC,IAAI,eAAe,EAAE;oBAClB,MAAM,cAAc,GAAW,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;oBAEjD,IAAI,cAAc,GAAG,CAAC,CAAC,EAAE;wBACtB,MAAM,SAAS,GAAW,IAAI,CAAC,SAAS,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;wBAE7D,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;4BACrD,OAAO,KAAK,CAAC;yBACf;wBAED,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;qBAC3C;iBACH;gBAED,IAAI,CAAC,8CAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;oBACtB,OAAO,KAAK,CAAC;iBACf;gBAED,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,eAAe,CAAC,kCAAkC,CAAC;uBAChF,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,eAAe,CAAC,qBAAqB,CAAC,CAAC;YAClF,CAAC,CAAC;YAEF;;;;;;eAMG;YACH,qBAAgB,GAAG,CAAC,cAAsB,EAAE,eAAuB,EAAE,UAAkB,EAAE,EAAE;gBACxF,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC;uBACnC,CAAC,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC;uBACzC,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;oBAC3C,OAAO,KAAK,CAAC;iBACf;gBAED,MAAM,YAAY,GAAa,cAAc,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;gBACpF,MAAM,aAAa,GAAa,eAAe,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;gBACtF,MAAM,WAAW,GAAa,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;oBAC/C,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC;oBACzE,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;gBAEzD,4BAA4B;gBAC5B,yBAAyB;gBACzB,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;oBACjC,IAAI,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;wBACjF,OAAO,KAAK,CAAC;qBACf;iBACH;gBAED,OAAO,IAAI,CAAC;YACf,CAAC,CAAC;YAMF;;;;;;eAMG;YACH,qBAAgB,GAAG,CAAC,cAAsB,EAAE,eAAuB,EAAE,MAAc,EAAE,EAAE;gBACpF,gHAAgH;gBAChH,iHAAiH;gBACjH,uEAAuE;gBACvE,OAAO,IAAI,CAAC;YACf,CAAC,CAAC;YACF;;;eAGG;YACH,mBAAc,GAAG,CAAC,SAAiB,EAAE,EAAE;gBACpC,OAAO,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;YACnF,CAAC,CAAC;YAEF,sBAAiB,GAAG,CAAC,SAAiB,EAAE,EAAE;gBACvC,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,EAAE;oBAC7F,OAAO,SAAS,CAAC;iBACnB;gBAED,MAAM,aAAa,GAAgB,uDAAK,CAAC,SAAS,CAAC,CAAC;gBACpD,OAAO,CAAC,OAAO,aAAa,CAAC,kBAAkB,KAAK,WAAW,CAAC;oBAC1D,CAAC,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;YAC1D,CAAC,CAAC;YAEF,qBAAgB,GAAG,CAAC,SAAiB,EAAE,EAAE;gBACtC,MAAM,cAAc,GAAa,SAAS,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;gBACjF,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC9B,OAAO,KAAK,CAAC;iBACf;gBAED,OAAO,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC;YACrE,CAAC,CAAC;YAEF,uBAAkB,GAAG,CAAC,QAAgB,EAAW,EAAE;gBAChD,MAAM,UAAU,GAAa,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBACjD,MAAM,MAAM,GAAY,uDAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,YAAY,8CAAI,CAAC;gBAC7D,iDAAiD;gBACjD,yCAAyC;gBACzC,MAAM,oBAAoB,GAAW,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACrD,MAAM,MAAM,GAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAEtC,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;oBAChB,OAAO,KAAK,CAAC;iBACf;gBACD,8CAA8C;gBAC9C,kDAAkD;gBAElD,IAAI,CAAC,MAAM,IAAI,MAAM,KAAK,EAAE,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM,KAAK,GAAG,CAAC,EAAE;oBAC3D,OAAO,IAAI,CAAC;iBACd;gBAED,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE;oBACvG,OAAO,KAAK,CAAC;iBACf;gBACD,MAAM,UAAU,GAAW,MAAM,GAAG,oBAAoB,CAAC;gBACzD,MAAM,uBAAuB,GAAW,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,oBAAoB,CAAC,CAAC;gBAElF,MAAM,SAAS,GAAa,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7D,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;oBAC9D,OAAO,KAAK,CAAC;iBACf;gBACD,6DAA6D;gBAC7D,wEAAwE;gBACxE,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,KAAK,GAAG,uBAAuB,CAAC,EAAE;oBAC/E,OAAO,KAAK,CAAC;iBACf;gBAED,0DAA0D;gBAC1D,kFAAkF;gBAClF,sFAAsF;gBACtF,IAAI,gBAAgB,GAAW,CAAC,CAAC;gBACjC,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,IAAI,UAAU,EAAE,CAAC,EAAE,EAAE;oBAC3C,gBAAgB,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,oBAAoB,GAAG,CAAC,CAAC,CAAC;iBAC5D;gBACD,wFAAwF;gBACxF,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC,uBAAuB,CAAC,CAAC,GAAG,gBAAgB,EAAE;oBAC7E,OAAO,KAAK,CAAC;iBACf;gBACD,OAAO,IAAI,CAAC;YACf,CAAC,CAAC;YAEM,iBAAY,GAAG,CAAC,KAAa,EAAY,EAAE;gBAChD,MAAM,EAAE,GAAgB,uDAAK,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,EAAE,YAAY,8CAAI,EAAE;oBACrB,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;iBAChC;gBACD,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAChC,CAAC,CAAC;YAEF,wBAAmB,GAAG,CAAC,MAAc,EAAE,EAAE;gBACtC,OAAO,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC;YACzC,CAAC,CAAC;YAEF,kBAAa,GAAG,CAAC,MAAc,EAAE,EAAE;gBAChC,OAAO,MAAM,IAAI,CAAC,IAAI,MAAM,IAAI,EAAE,CAAC;YACtC,CAAC,CAAC;YAEF,sBAAiB,GAAG,CAAC,UAAkB,EAAE,EAAE;gBACxC,IAAI,CAAC,UAAU,EAAE;oBACd,OAAO,KAAK,CAAC;iBACf;gBAED,2DAA2D;gBAC3D,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE,EAAE;oBACxC,OAAO,IAAI,CAAC;iBACd;gBAED,iFAAiF;gBACjF,gFAAgF;gBAChF,6DAA6D;gBAC7D,MAAM,SAAS,GAAa,EAAE,CAAC;gBAC/B,UAAU,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;oBAChE,IAAI,CAAC,CAAC,KAAK,EAAE;wBACV,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;qBAChC;gBACJ,CAAC,CAAC,CAAC;gBAEH,6CAA6C;gBAC7C,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;oBAC/C,OAAO,KAAK,CAAC;iBACf;gBAED,+CAA+C;gBAC/C,IAAI,oBAAoB,GAAW,CAAC,CAAC;gBAErC,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;oBAC/B,IAAI,QAAQ,KAAK,eAAe,CAAC,0BAA0B,EAAE;wBAC1D,MAAM;qBACR;yBAAM;wBACJ,oBAAoB,EAAE,CAAC;qBACzB;iBACH;gBAED,kDAAkD;gBAClD,IAAI,oBAAoB,KAAK,SAAS,CAAC,MAAM,EAAE;oBAC5C,OAAO,IAAI,CAAC;iBACd;gBAED,4BAA4B;gBAC5B,IAAI,eAAe,CAAC,6BAA6B,CAAC,OAAO,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;oBAChG,OAAO,KAAK,CAAC;iBACf;gBAED,iCAAiC;gBACjC,KAAK,IAAI,CAAC,GAAW,oBAAoB,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACvE,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;wBACrB,OAAO,KAAK,CAAC;qBACf;iBACH;gBAED,OAAO,IAAI,CAAC;YACf,CAAC,CAAC;YAwBF;;;;;;;eAOG;YACH,uBAAkB,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,EAAE;gBACnD,OAAO,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;YACxF,CAAC,CAAC;YAEF;;;;eAIG;YACH,6BAAwB,GAAG,CAAC,SAAiB,EAAE,EAAE;gBAC9C,IAAI,IAAI,GAAgB,uDAAK,CAAC,SAAS,CAAC,CAAC;gBAEzC,IAAI,IAAI,YAAY,8CAAI,EAAE;oBACvB,IAAI,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;iBACpC;gBAED,OAAO,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACpC,CAAC,CAAC;YAEF,UAAK,GAAG,CAAC,aAAqB,EAAE,EAAE;gBAC/B,MAAM,cAAc,GAAQ,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;gBAC5D,MAAM,UAAU,GAAQ,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC5D,MAAM,aAAa,GAAQ,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;gBAErE,IAAI,UAAU,CAAC,KAAK,IAAI,aAAa,CAAC,KAAK,EAAE;oBAC1C,OAAO,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,OAAO,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;iBACrE;qBAAM;oBACJ,OAAO,IAAI,CAAC;iBACd;YACJ,CAAC,CAAC;YAEF,gBAAW,GAAG,CAAC,aAAqB,EAAE,EAAE;gBACrC,MAAM,KAAK,GAAa,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBAEjD,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;oBACnB,OAAO,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;iBAC7C;qBAAM;oBACJ,OAAO;wBACJ,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;wBACjB,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;qBAChB,CAAC;iBACJ;YACJ,CAAC,CAAC;YAEF,oBAAe,GAAG,CAAC,OAAe,EAAE,EAAE;gBACnC,MAAM,KAAK,GAA2B,eAAe,CAAC,6BAA6B,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAClG,IAAI,KAAK,EAAE;oBACR,OAAO;wBACJ,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;wBACjB,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;qBAChB,CAAC;iBACJ;qBAAM;oBACJ,OAAO;wBACJ,OAAO,EAAE,OAAO;qBAClB,CAAC;iBACJ;YACJ,CAAC,CAAC;YAEF,iBAAY,GAAG,CAAC,OAAe,EAAsC,EAAE;gBACpE,IAAI,CAAC,8CAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,8CAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBACnD,OAAO,EAAC,KAAK,EAAE,KAAK,EAAC,CAAC;iBACxB;gBAED,OAAO;oBACJ,KAAK,EAAE,IAAI;oBACX,OAAO,EAAE,uDAAK,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE;iBACpC,CAAC;YACL,CAAC,CAAC;YAEF,cAAS,GAAG,CAAC,IAAY,EAAE,EAAE;gBAC1B,IAAI,IAAI,KAAK,SAAS,EAAE;oBACrB,OAAO,EAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAC,CAAC;iBACxC;gBAED,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBAC3C,OAAO,EAAC,KAAK,EAAE,KAAK,EAAC,CAAC;iBACxB;gBAED,MAAM,UAAU,GAAW,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;gBAC9C,IAAI,UAAU,IAAI,CAAC,EAAE;oBAClB,OAAO,EAAC,KAAK,EAAE,KAAK,EAAC,CAAC;iBACxB;qBAAM,IAAI,UAAU,IAAI,eAAe,CAAC,QAAQ,EAAE;oBAChD,OAAO,EAAC,KAAK,EAAE,KAAK,EAAC,CAAC;iBACxB;qBAAM;oBACJ,OAAO,EAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAC,CAAC;iBACzC;YACJ,CAAC,CAAC;YAEF,mBAAc,GAAG,CAAC,OAAe,EAAE,IAAY,EAAE,EAAE;gBAChD,OAAO;oBACJ,OAAO,EAAE,OAAO;oBAChB,IAAI,EAAE,IAAI;iBACZ,CAAC;YACL,CAAC,CAAC;QAuBL,CAAC;QAtTU,MAAM,CAAC,IAAY;YACxB,OAAO,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;QAkKD;;;WAGG;QACH,eAAe,CAAC,IAAY;YACzB,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;gBACxC,OAAO,EAAE,CAAC;aACZ;YACD,MAAM,uBAAuB,GAAW,CAAC,CAAC;YAC1C,MAAM,MAAM,GAAa,EAAE,CAAC;YAC5B,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,uBAAuB,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC1E,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,0BAA0B,CAAC,CAAC;aAC1D;YACD,IAAI,IAAI,GAAG,uBAAuB,KAAK,CAAC,EAAE;gBACvC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,6BAA6B,CAAC,IAAI,GAAG,uBAAuB,GAAG,CAAC,CAAC,CAAC,CAAC;aACjG;YACD,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC,CAAC;aAChE;YACD,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;QACtD,CAAC;QAyGD;;;;;;;;;;WAUG;QACH,sBAAsB,CAAC,OAAsB,EAAE,YAAY,GAAW,EAAE;YACrE,IAAI,CAAC,OAAO;gBACN,YAAY,KAAK,eAAe,CAAC,6BAA6B;gBAC9D,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,OAAO,KAAK,CAAC;aACf;YAED,MAAM,eAAe,GAAW,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACnE,OAAO,CAAC,eAAe,GAAG,MAAM,CAAC,KAAK,MAAM,CAAC;QAChD,CAAC;;IApYuB,0CAA0B,GAAW,GAAG,CAAC;IAEzC,6CAA6B,GAAa,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IACjF,wBAAQ,GAAW,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAE3D,+DAA+D;IACvC,6CAA6B,GAAW,IAAI,MAAM,CAAC,wBAAwB,CAAC,CAAC;IAC7E,4BAAY,GAAW,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC5C,iCAAiB,GAAY,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC;IACjD,6CAA6B,GAAW,EAAE,CAAC;IAC3C,kDAAkC,GAAW,IAAI,CAAC;IAClD,qCAAqB,GAAW,KAAK,CAAC;IACtC,8BAAc,GAAW,GAAG,CAAC","file":"65-es2015.js","sourcesContent":["(function() {\n  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;\n\n  ipaddr = {};\n\n  root = this;\n\n  if ((typeof module !== \"undefined\" && module !== null) && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root['ipaddr'] = ipaddr;\n  }\n\n  matchCIDR = function(first, second, partSize, cidrBits) {\n    var part, shift;\n    if (first.length !== second.length) {\n      throw new Error(\"ipaddr: cannot match CIDR for objects with different lengths\");\n    }\n    part = 0;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  };\n\n  ipaddr.subnetMatch = function(address, rangeList, defaultName) {\n    var k, len, rangeName, rangeSubnets, subnet;\n    if (defaultName == null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      rangeSubnets = rangeList[rangeName];\n      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n        rangeSubnets = [rangeSubnets];\n      }\n      for (k = 0, len = rangeSubnets.length; k < len; k++) {\n        subnet = rangeSubnets[k];\n        if (address.kind() === subnet[0].kind()) {\n          if (address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  ipaddr.IPv4 = (function() {\n    function IPv4(octets) {\n      var k, len, octet;\n      if (octets.length !== 4) {\n        throw new Error(\"ipaddr: ipv4 octet count should be 4\");\n      }\n      for (k = 0, len = octets.length; k < len; k++) {\n        octet = octets[k];\n        if (!((0 <= octet && octet <= 255))) {\n          throw new Error(\"ipaddr: ipv4 octet should fit in 8 bits\");\n        }\n      }\n      this.octets = octets;\n    }\n\n    IPv4.prototype.kind = function() {\n      return 'ipv4';\n    };\n\n    IPv4.prototype.toString = function() {\n      return this.octets.join(\".\");\n    };\n\n    IPv4.prototype.toNormalizedString = function() {\n      return this.toString();\n    };\n\n    IPv4.prototype.toByteArray = function() {\n      return this.octets.slice(0);\n    };\n\n    IPv4.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error(\"ipaddr: cannot match ipv4 address with non-ipv4 one\");\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      \"private\": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    };\n\n    IPv4.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv4.prototype.toIPv4MappedAddress = function() {\n      return ipaddr.IPv6.parse(\"::ffff:\" + (this.toString()));\n    };\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, octet, stop, zeros, zerotable;\n      zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 3; k >= 0; i = k += -1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    return IPv4;\n\n  })();\n\n  ipv4Part = \"(0?\\\\d+|0x[a-f0-9]+)\";\n\n  ipv4Regexes = {\n    fourOctet: new RegExp(\"^\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"$\", 'i'),\n    longValue: new RegExp(\"^\" + ipv4Part + \"$\", 'i')\n  };\n\n  ipaddr.IPv4.parser = function(string) {\n    var match, parseIntAuto, part, shift, value;\n    parseIntAuto = function(string) {\n      if (string[0] === \"0\" && string[1] !== \"x\") {\n        return parseInt(string, 8);\n      } else {\n        return parseInt(string);\n      }\n    };\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return (function() {\n        var k, len, ref, results;\n        ref = match.slice(1, 6);\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      })();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error(\"ipaddr: address outside defined range\");\n      }\n      return ((function() {\n        var k, results;\n        results = [];\n        for (shift = k = 0; k <= 24; shift = k += 8) {\n          results.push((value >> shift) & 0xff);\n        }\n        return results;\n      })()).reverse();\n    } else {\n      return null;\n    }\n  };\n\n  ipaddr.IPv6 = (function() {\n    function IPv6(parts, zoneId) {\n      var i, k, l, len, part, ref;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = k = 0; k <= 14; i = k += 2) {\n          this.parts.push((parts[i] << 8) | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error(\"ipaddr: ipv6 part count should be 8 or 16\");\n      }\n      ref = this.parts;\n      for (l = 0, len = ref.length; l < len; l++) {\n        part = ref[l];\n        if (!((0 <= part && part <= 0xffff))) {\n          throw new Error(\"ipaddr: ipv6 part should fit in 16 bits\");\n        }\n      }\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    }\n\n    IPv6.prototype.kind = function() {\n      return 'ipv6';\n    };\n\n    IPv6.prototype.toString = function() {\n      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n    };\n\n    IPv6.prototype.toByteArray = function() {\n      var bytes, k, len, part, ref;\n      bytes = [];\n      ref = this.parts;\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    IPv6.prototype.toNormalizedString = function() {\n      var addr, part, suffix;\n      addr = ((function() {\n        var k, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(part.toString(16));\n        }\n        return results;\n      }).call(this)).join(\":\");\n      suffix = '';\n      if (this.zoneId) {\n        suffix = '%' + this.zoneId;\n      }\n      return addr + suffix;\n    };\n\n    IPv6.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error(\"ipaddr: cannot match ipv6 address with non-ipv6 one\");\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    IPv6.prototype.SpecialRanges = {\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    IPv6.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv6.prototype.isIPv4MappedAddress = function() {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    IPv6.prototype.toIPv4Address = function() {\n      var high, low, ref;\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error(\"ipaddr: trying to convert a generic ipv6 address to ipv4\");\n      }\n      ref = this.parts.slice(-2), high = ref[0], low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    IPv6.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, part, stop, zeros, zerotable;\n      zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 7; k >= 0; i = k += -1) {\n        part = this.parts[i];\n        if (part in zerotable) {\n          zeros = zerotable[part];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 16) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 128 - cidr;\n    };\n\n    return IPv6;\n\n  })();\n\n  ipv6Part = \"(?:[0-9a-f]+::?)+\";\n\n  zoneIndex = \"%[0-9a-z]{1,}\";\n\n  ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    \"native\": new RegExp(\"^(::)?(\" + ipv6Part + \")?([0-9a-f]+)?(::)?(\" + zoneIndex + \")?$\", 'i'),\n    transitional: new RegExp((\"^((?:\" + ipv6Part + \")|(?:::)(?:\" + ipv6Part + \")?)\") + (ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part) + (\"(\" + zoneIndex + \")?$\"), 'i')\n  };\n\n  expandIPv6 = function(string, parts) {\n    var colonCount, lastColon, part, replacement, replacementCount, zoneId;\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    }\n    colonCount = 0;\n    lastColon = -1;\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n    if (colonCount > parts) {\n      return null;\n    }\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n    string = string.replace('::', replacement);\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    parts = (function() {\n      var k, len, ref, results;\n      ref = string.split(\":\");\n      results = [];\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        results.push(parseInt(part, 16));\n      }\n      return results;\n    })();\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  };\n\n  ipaddr.IPv6.parser = function(string) {\n    var addr, k, len, match, octet, octets, zoneId;\n    if (ipv6Regexes['native'].test(string)) {\n      return expandIPv6(string, 8);\n    } else if (match = string.match(ipv6Regexes['transitional'])) {\n      zoneId = match[6] || '';\n      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (k = 0, len = octets.length; k < len; k++) {\n          octet = octets[k];\n          if (!((0 <= octet && octet <= 255))) {\n            return null;\n          }\n        }\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n    return null;\n  };\n\n  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {\n    return this.parser(string) !== null;\n  };\n\n  ipaddr.IPv4.isValid = function(string) {\n    var e;\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.isValidFourPartDecimal = function(string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^\\d+(\\.\\d+){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ipaddr.IPv6.isValid = function(string) {\n    var addr, e;\n    if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n      return false;\n    }\n    try {\n      addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.parse = function(string) {\n    var parts;\n    parts = this.parser(string);\n    if (parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(parts);\n  };\n\n  ipaddr.IPv6.parse = function(string) {\n    var addr;\n    addr = this.parser(string);\n    if (addr.parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(addr.parts, addr.zoneId);\n  };\n\n  ipaddr.IPv4.parseCIDR = function(string) {\n    var maskLength, match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        return [this.parse(match[1]), maskLength];\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv4 CIDR range\");\n  };\n\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {\n    var filledOctetCount, j, octets;\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n    octets = [0, 0, 0, 0];\n    j = 0;\n    filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n    }\n    return new this(octets);\n  };\n\n  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv4.networkAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv6.parseCIDR = function(string) {\n    var maskLength, match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        return [this.parse(match[1]), maskLength];\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv6 CIDR range\");\n  };\n\n  ipaddr.isValid = function(string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  ipaddr.parse = function(string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 format\");\n    }\n  };\n\n  ipaddr.parseCIDR = function(string) {\n    var e;\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (error1) {\n      e = error1;\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (error1) {\n        e = error1;\n        throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 CIDR format\");\n      }\n    }\n  };\n\n  ipaddr.fromByteArray = function(bytes) {\n    var length;\n    length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error(\"ipaddr: the binary input is neither an IPv6 nor IPv4 address\");\n    }\n  };\n\n  ipaddr.process = function(string) {\n    var addr;\n    addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n}).call(this);\n","/* Copyright 2017-2021 VMware, Inc. All rights reserved. -- VMware Confidential */\nimport {Injectable} from \"@angular/core\";\nimport {IPv4, IPv6, parse} from \"ipaddr.js\";\n\n/**\n * Service to parse IP addresses and some utility methods related to them.\n * Same as js-ui-lib/src/main/ui/services/ipParserService.js for AngularJS and\n * ng-next-app/src/app/platform/services/parser/ip-parser.service.ts\n */\n@Injectable()\nexport class IpParserService {\n\n   private static readonly SUBNET_MASK_MAX_QUAD_VALUE: number = 255;\n\n   private static readonly SUBNET_MASK_VALID_QUAD_VALUES: number[] = [0, 128, 192, 224, 240, 248, 252, 254];\n   private static readonly MAX_PORT: number = Math.pow(2, 16);\n\n   // capture groups are: [fullText, address, portWithColon, port]\n   private static readonly IPV6_BRACKETED_NOTATION_REGEX: RegExp = new RegExp(\"^\\\\[(.*)\\\\](:(\\\\d+))?$\");\n   private static readonly DIGITS_REGEX: RegExp = new RegExp(\"^\\\\d+$\");\n   private static readonly ZONE_INDEX_REGEXP: RegExp =  new RegExp(\"^\\w+$\");\n   private static readonly IPV6_LINK_LOCAL_PREFIX_LENGTH: number = 64;\n   private static readonly IPV6_DEFAULT_UNICAST_ROUTE_ADDRESS: string = \"::\";\n   private static readonly IPV6_LOOPBACK_ADDRESS: string = \"::1\";\n   private static readonly IPV4_SEPARATOR: string = \".\";\n\n   isIpv4AddressValid = (ipAddress: string) => {\n      const trimmedIp: string = ipAddress.trim();\n      return IPv4.isValid(trimmedIp) && this.validIpV4Address(trimmedIp);\n   };\n\n   isIpv6AddressValid = (ipAddress: string, acceptZoneIndex: boolean = false): boolean => {\n      if (!ipAddress) {\n         return false;\n      }\n\n      let addr: string = ipAddress.trim();\n\n      if (acceptZoneIndex) {\n         const delimiterIndex: number = addr.indexOf(\"%\");\n\n         if (delimiterIndex > -1) {\n            const zoneIndex: string = addr.substring(delimiterIndex + 1);\n\n            if (!IpParserService.ZONE_INDEX_REGEXP.test(zoneIndex)) {\n               return false;\n            }\n\n            addr = addr.substring(0, delimiterIndex);\n         }\n      }\n\n      if (!IPv6.isValid(addr)) {\n         return false;\n      }\n\n      return !this.equalIpv6Addresses(addr, IpParserService.IPV6_DEFAULT_UNICAST_ROUTE_ADDRESS)\n            && !this.equalIpv6Addresses(addr, IpParserService.IPV6_LOOPBACK_ADDRESS);\n   };\n\n   /**\n    * @param ipAddressFirst - first ipv4Address for comparison\n    * @param ipAddressSecond - second ipv4Address for comparison\n    * @param subnetMask - subnetMask associated with the given IPs\n    * @returns {boolean} true if all parameters are valid and ipAddressFirst\n    *          subnet matches the ipAddressSecond subnet, otherwise returns false\n    */\n   isSameIpv4Subnet = (ipAddressFirst: string, ipAddressSecond: string, subnetMask: string) => {\n      if (!this.isIpv4AddressValid(ipAddressFirst)\n            || !this.isIpv4AddressValid(ipAddressSecond)\n            || !this.isSubnetMaskValid(subnetMask)) {\n         return false;\n      }\n\n      const splitIpFirst: string[] = ipAddressFirst.split(IpParserService.IPV4_SEPARATOR);\n      const splitIpSecond: string[] = ipAddressSecond.split(IpParserService.IPV4_SEPARATOR);\n      const splitSubnet: string[] = this.isCidr(subnetMask)\n            ? this.parseCidrToIpv4(+subnetMask).split(IpParserService.IPV4_SEPARATOR)\n            : subnetMask.split(IpParserService.IPV4_SEPARATOR);\n\n      // enable bitwise operations\n      /*jshint bitwise:false */\n      for (let i: number = 0; i < 4; i++) {\n         if ((+splitIpFirst[i] & +splitSubnet[i]) !== (+splitIpSecond[i] & +splitSubnet[i])) {\n            return false;\n         }\n      }\n\n      return true;\n   };\n\n   private isCidr(mask: string): boolean {\n      return !isNaN(+mask);\n   }\n\n   /**\n    * @param ipAddressFirst - first ipv6Address for comparison\n    * @param ipAddressSecond - second ipv6Address for comparison. Expect gateway\n    * @param prefix - prefix associated with the given IPs\n    * @returns {boolean} true if all parameters are valid and ipAddressFirst\n    *          subnet matches the ipAddressSecond subnet, otherwise returns false\n    */\n   isSameIpv6Subnet = (ipAddressFirst: string, ipAddressSecond: string, prefix: string) => {\n      // The network validation (UI and backend) for ipv6 addresses does not include validation for same ipv6 subnets.\n      // Return true to have consistent validations (UI and API), but keep the method to make an easy change if needed.\n      // More info in https://bugzilla.eng.vmware.com/show_bug.cgi?id=2583003\n      return true;\n   };\n   /**\n    * Returns true if provided ipAddress is valid IPv4 or IPv6 address\n    * @param ipAddress\n    */\n   isAddressValid = (ipAddress: string) => {\n      return this.isIpv6AddressValid(ipAddress) || this.isIpv4AddressValid(ipAddress);\n   };\n\n   expandIpv6Address = (ipAddress: string) => {\n      if (!ipAddress || (!this.isIpv4AddressValid(ipAddress) && !this.isIpv6AddressValid(ipAddress))) {\n         return ipAddress;\n      }\n\n      const parsedAddress: IPv4 | IPv6 = parse(ipAddress);\n      return (typeof parsedAddress.toNormalizedString !== \"undefined\")\n            ? parsedAddress.toNormalizedString() : ipAddress;\n   };\n\n   validIpV4Address = (ipAddress: string) => {\n      const splitIpAddress: string[] = ipAddress.split(IpParserService.IPV4_SEPARATOR);\n      if (splitIpAddress.length !== 4) {\n         return false;\n      }\n\n      return splitIpAddress.every((item) => +item >= 0 && +item <= 255);\n   };\n\n   isSubnetForIpValid = (ipString: string): boolean => {\n      const ipSections: string[] = ipString.split(\"/\");\n      const isIPv4: boolean = parse(ipSections[0]) instanceof IPv4;\n      // IPv4 is 32 bits, each part is a 8 bits number;\n      // IPv6 is 128 bits, each part is 16 bits\n      const ipAddressDigitsCount: number = isIPv4 ? 8 : 16;\n      const subnet: number = +ipSections[1];\n\n      if (isNaN(subnet)) {\n         return false;\n      }\n      // IPv4: subnet === 32 or IPv6: subnet === 128\n      // this means we allow all, so no need to validate\n\n      if ((isIPv4 && subnet === 32) || (!isIPv4 && subnet === 128)) {\n         return true;\n      }\n\n      if ((isIPv4 && !this.isSubnetValid(subnet)) || (!isIPv4 && !this.isSubnetPrefixValid(subnet.toString()))) {\n         return false;\n      }\n      const highDigits: number = subnet % ipAddressDigitsCount;\n      const validationStartPosition: number = Math.floor(subnet / ipAddressDigitsCount);\n\n      const ipNumbers: number[] = this.parseIpToNum(ipSections[0]);\n      if (ipNumbers.length === 0 || ipNumbers.find(num => isNaN(num))) {\n         return false;\n      }\n      // all the ip numbers after the starting position should be 0\n      // for example: 10.160.0.1/16 is invalid, the valid ip is: 10.160.0.0/16\n      if (ipNumbers.find((num, index) => num !== 0 && index > validationStartPosition)) {\n         return false;\n      }\n\n      // Now we are checking the number at the starting position\n      // for example: the highDigits is 5, it means 11111000, the first 5 bits are all 1\n      // the number at starting position cannot have 1 at the last 3 bits in its binary form\n      let subnetValidation: number = 0;\n      for (let i: number = 1; i <= highDigits; i++) {\n         subnetValidation += Math.pow(2, ipAddressDigitsCount - i);\n      }\n      // for a valid ip number, the or operation returns a number that <= the subnetValidation\n      if ((subnetValidation | ipNumbers[validationStartPosition]) > subnetValidation) {\n         return false;\n      }\n      return true;\n   };\n\n   private parseIpToNum = (ipStr: string): number[] => {\n      const ip: IPv4 | IPv6 = parse(ipStr);\n      if (ip instanceof IPv4) {\n         return ip ? ip[\"octets\"] : [];\n      }\n      return ip ? ip[\"parts\"] : [];\n   };\n\n   isSubnetPrefixValid = (prefix: string) => {\n      return +prefix >= 1 && +prefix <= 128;\n   };\n\n   isSubnetValid = (subnet: number) => {\n      return subnet >= 1 && subnet <= 32;\n   };\n\n   isSubnetMaskValid = (subnetMask: string) => {\n      if (!subnetMask) {\n         return false;\n      }\n\n      // support cidr(Classless Inter-Domain Routing) subnet mask\n      if (+subnetMask >= 0 && +subnetMask <= 32) {\n         return true;\n      }\n\n      // If the mask ends with '.', or has no number between two '.', then the .split()\n      // would return \"\" in this case, which transformed into a number results in `0`.\n      // This should be avoided by filtering the non-empty strings.\n      const maskBytes: number[] = [];\n      subnetMask.split(IpParserService.IPV4_SEPARATOR).forEach((octet) => {\n         if (!!octet) {\n            maskBytes.push(Number(octet));\n         }\n      });\n\n      // The first octet cannot be 0 for a valid IP\n      if (maskBytes.length !== 4 || maskBytes[0] === 0) {\n         return false;\n      }\n\n      // Find the first quad that is not equal to 255\n      let firstNonMaxQuadIndex: number = 0;\n\n      for (const maskByte of maskBytes) {\n         if (maskByte !== IpParserService.SUBNET_MASK_MAX_QUAD_VALUE) {\n            break;\n         } else {\n            firstNonMaxQuadIndex++;\n         }\n      }\n\n      // All quads are equal to 255 -> valid subnet mask\n      if (firstNonMaxQuadIndex === maskBytes.length) {\n         return true;\n      }\n\n      // Quad should be contiguous\n      if (IpParserService.SUBNET_MASK_VALID_QUAD_VALUES.indexOf(maskBytes[firstNonMaxQuadIndex]) === -1) {\n         return false;\n      }\n\n      // Following quads should be zero\n      for (let j: number = firstNonMaxQuadIndex + 1; j < maskBytes.length; j++) {\n         if (maskBytes[j] !== 0) {\n            return false;\n         }\n      }\n\n      return true;\n   };\n\n   /**\n    * detailed information about CIDR, please check this link:\n    * https://docs.netgate.com/pfsense/en/latest/book/network/understanding-cidr-subnet-mask-notation.html\n    */\n   parseCidrToIpv4(cidr: number): string {\n      if (!this.isSubnetMaskValid(String(cidr))) {\n         return \"\";\n      }\n      const IP_ADDRESS_DIGITS_COUNT: number = 8;\n      const subnet: number[] = [];\n      for (let i: number = 0; i < Math.floor(cidr / IP_ADDRESS_DIGITS_COUNT); i++) {\n         subnet.push(IpParserService.SUBNET_MASK_MAX_QUAD_VALUE);\n      }\n      if (cidr % IP_ADDRESS_DIGITS_COUNT !== 0) {\n         subnet.push(IpParserService.SUBNET_MASK_VALID_QUAD_VALUES[cidr % IP_ADDRESS_DIGITS_COUNT - 1]);\n      }\n      while (subnet.length < 4) {\n         subnet.push(IpParserService.SUBNET_MASK_VALID_QUAD_VALUES[0]);\n      }\n      return subnet.join(IpParserService.IPV4_SEPARATOR);\n   }\n\n   /**\n    * Compares its two ipv6 addresses. Returns true if it's the same ip address even\n    * if the format is different.\n    *\n    * @param addr1 The first valid ipv6 address to be compared\n    * @param addr2 The second valid ipv6 address to be compared\n    * @returns {boolean}\n    */\n   equalIpv6Addresses = (addr1: string, addr2: string) => {\n      return this.getNormalizedIpv6Address(addr1) === this.getNormalizedIpv6Address(addr2);\n   };\n\n   /**\n    * Returns normalized form of IPv6 and IPv4 address\n    * @param ipAddress\n    *\n    */\n   getNormalizedIpv6Address = (ipAddress: string) => {\n      let addr: IPv4 | IPv6 = parse(ipAddress);\n\n      if (addr instanceof IPv4) {\n         addr = addr.toIPv4MappedAddress();\n      }\n\n      return addr.toNormalizedString();\n   };\n\n   parse = (addressString: string) => {\n      const addressAndPort: any = this.detectParts(addressString);\n      const portResult: any = this.parsePort(addressAndPort.port);\n      const addressResult: any = this.parseAddress(addressAndPort.address);\n\n      if (portResult.valid && addressResult.valid) {\n         return this.buildIpAddress(addressResult.address, portResult.port);\n      } else {\n         return null;\n      }\n   };\n\n   detectParts = (addressString: string) => {\n      const parts: string[] = addressString.split(\":\");\n\n      if (parts.length > 2) {\n         return this.detectIPv6Parts(addressString);\n      } else {\n         return {\n            address: parts[0],\n            port: parts[1],\n         };\n      }\n   };\n\n   detectIPv6Parts = (address: string) => {\n      const match: RegExpExecArray | null = IpParserService.IPV6_BRACKETED_NOTATION_REGEX.exec(address);\n      if (match) {\n         return {\n            address: match[1],\n            port: match[3],\n         };\n      } else {\n         return {\n            address: address,\n         };\n      }\n   };\n\n   parseAddress = (address: string): {valid: boolean, address?: string} => {\n      if (!IPv4.isValid(address) && !IPv6.isValid(address)) {\n         return {valid: false};\n      }\n\n      return {\n         valid: true,\n         address: parse(address).toString(),\n      };\n   };\n\n   parsePort = (port: string) => {\n      if (port === undefined) {\n         return {valid: true, port: undefined};\n      }\n\n      if (!IpParserService.DIGITS_REGEX.test(port)) {\n         return {valid: false};\n      }\n\n      const parsedPort: number = parseInt(port, 10);\n      if (parsedPort <= 0) {\n         return {valid: false};\n      } else if (parsedPort >= IpParserService.MAX_PORT) {\n         return {valid: false};\n      } else {\n         return {valid: true, port: parsedPort};\n      }\n   };\n\n   buildIpAddress = (address: string, port: string) => {\n      return {\n         address: address,\n         port: port,\n      };\n   };\n\n   /**\n    * Checks if IPv6 address is a link local address i.e. of the type fe80::/10\n    * (fe80:: through febf::)\n    *\n    * @param address\n    *    IPv6 address\n    * @param prefixLength\n    *    IPv6 prefix length - link-local addresses have a prefix length of 64\n    * @return\n    *    Returns true if the address is a link local one\n    */\n   isLinkLocalIpv6Address(address: string | null, prefixLength: number = 64): boolean {\n      if (!address ||\n            prefixLength !== IpParserService.IPV6_LINK_LOCAL_PREFIX_LENGTH ||\n            address.length < 4) {\n         return false;\n      }\n\n      const addressBegining: number = parseInt(address.substr(0, 4), 16);\n      return (addressBegining & 0xffc0) === 0xfe80;\n   }\n}\n"],"sourceRoot":"webpack:///"}