{"version":3,"sources":["webpack:///src/app/vsan/common/component/upgrade/upgrade.data.ts","webpack:///src/app/vsan/common/util/disk-mgmt-host.util.ts","webpack:///src/app/vsan/common/service/navigation/model/knowledge-base-id.ts","webpack:///src/app/vsan/common/util/disk-mgmt-disk-group.util.ts","webpack:///src/app/vsan/common/component/upgrade/upgrade.service.ts","webpack:///src/app/vsan/common/component/diskmgmt/model/storage-identifier.ts"],"names":["UpgradeData","diskData","upgradeStatus","hasOldVsanObject","latestVersion","versions","getVersions","upgradeDiskData","UpgradeDisksData","create","hasPrecheckRunInformation","isPrecheck","isDataMovementRequired","isUpgraded","hasDisks","minVersion","hasPrecheckIssues","inProgress","issues","length","status","getStatus","isUpgradeInProgress","VsanUpgradeStatus","IN_PROGRESS","isAsyncPrecheckSupported","isUpToDate","getIsUpToDate","latestVersionAsString","toFixed","precheckStatus","getPrecheckStatus","Map","filter","disk","vsanDiskInfo","forEach","isHealthy","formatVersion","getFormatVersion","diskStatus","count","get","set","maxVersion","includeCompatibilityWarning","statusText","getString","hasMixedDiskVersions","olderNumOfDisks","totalNumOfDisks","getUpgradeWithIssuesStatus","minVersionAsString","UNKNOWN","completed","COMPLETED","aborted","ABORTED","getStatusLabelWithTime","operationLabelKey","operationLabel","lastOperationDate","lastOperationTime","formatDate","Number","MAX_VALUE","totalVersionsInCluster","MIN_VALUE","result","value","key","versionNum","parseInt","minVersionKey","maxVersionKey","DiskMgmtHostUtil","host","state","notResponding","disconnected","isInMaintenanceMode","diskGroups","group","isVsanDiskGroup","groupHealthKey","getHealthKey","HEALTHY_MSG_KEY","healthStatus","HealthStatus","HEALTHY","UNHEALTHY","UNHEALTHY_MSG_KEY","UNKNOWN_MSG_KEY","clusterCapabilities","isHostResourcePrecheckSupported","claimableState","IN_USE","disks","IN_USE_BY_VSAN","concat","ONLY_MANAGED_BY_VSAN","USABLE","ELIGIBLE","NOT_USABLE","INELIGIBLE","pmemStorage","claimDistribution","getDistributionCount","hosts","sort","h1","h2","getHealthKeyOrderPriority","getDisks","getPmemStorage","healthKey","LOCKED_MSG_KEY","UNMOUNTED_MSG_KEY","MAX_SAFE_INTEGER","hostList","isEmpty","connected","isWitnessHost","reduce","sum","getClaimDistribution","getGroupTypeKeys","map","getKey","v","i","a","indexOf","getClaimedDisksLabel","KnowledgeBaseId","DiskMgmtDiskGroupUtil","diskGroup","ALL_FLASH","HYBRID","includes","diskGroupType","VSAN_DIRECT","PMEM","SINGLE_TIER","storageGroup","UNUSED","isMounted","isLocked","every","isVsanMaxSingleTier","DiskGroupKey","VSAN","isVsanDirectDiskGroup","isPmemDiskGroup","labelFormat","getVsanLabel","name","uuid","VsanDiskGroupLabelFormat","TYPE","TYPE_AND_UUID","UUID","cacheDisk","find","isMappedAsCache","isDiskResourcePrecheckSupported","storage","some","areEqual","getBreadcrumbPreselectedDiskGroup","isSingleTierEnabled","UpgradeService","upgradePropertyProvider","upgradeMutationProvider","diskMgmtService","clusterRef","Promise","accept","reject","listHosts","then","hostDisksData","getUpgradeOnlyData","error","hostDisks","claimedDisks","getClaimedDisks","all","getUpgradeStatus","hasOldFormatObjects","getLatestVsanVersion","upgradeStatusData","getVsanUpgradeStatus","getHasOldVsanObject","upgradeData","contextObject","performUpgradePreflightAsyncCheck","StorageIdentifier","value1","value2"],"mappings":"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","file":"42-es5.js","sourcesContent":["/* Copyright 2016-2022 VMware, Inc. All rights reserved. -- VMware Confidential */\nimport {DiskData} from \"@generated/disk-data\";\nimport {VsanUpgradeStatusData} from \"@generated/vsan-upgrade-status-data\";\nimport {DiskMgmtDiskUtil} from \"@util/disk-mgmt-disk.util\";\nimport {VsanDateTimeUtils} from \"@util/vsan-dateteime-util\";\nimport {VsanUiUtils} from \"@util/vsan-util\";\n\nexport class UpgradeData {\n\n   upgradeDiskData: UpgradeDisksData;\n   hasPrecheckRunInformation: boolean;\n   isDataMovementRequired: boolean;\n   // Is vSAN cluster is upgraded.\n   isUpgraded: boolean;\n   hasPrecheckIssues: boolean;\n   isUpgradeInProgress: boolean;\n   isAsyncPrecheckSupported: boolean;\n   isUpToDate: boolean;\n   latestVersionAsString: string;\n   status: VsanUpgradeStatus;\n   precheckStatus: string;\n\n   constructor(public diskData: DiskData[],\n         public upgradeStatus: VsanUpgradeStatusData,\n         public hasOldVsanObject: boolean,\n         public latestVersion: number) {\n      // Populate the upgrade data, based on the input disks\n      const versions: Map<string, number> = this.getVersions();\n      this.upgradeDiskData = UpgradeDisksData.create(versions, latestVersion);\n      this.hasPrecheckRunInformation = !!this.upgradeStatus?.isPrecheck;\n      this.isDataMovementRequired = this.upgradeDiskData && this.upgradeStatus?.isDataMovementRequired;\n      this.isUpgraded = !this.upgradeDiskData.hasDisks || (this.upgradeDiskData.minVersion >= this.latestVersion);\n      this.hasPrecheckIssues = this.upgradeStatus && !this.upgradeStatus.inProgress && this.upgradeStatus.isPrecheck\n            && !!this.upgradeStatus.issues?.length;\n      this.status = this.getStatus();\n      this.isUpgradeInProgress =\n            this.upgradeStatus && !this.upgradeStatus.isPrecheck && this.status === VsanUpgradeStatus.IN_PROGRESS;\n      this.isAsyncPrecheckSupported = !!this.upgradeStatus?.isAsyncPrecheckSupported;\n      this.isUpToDate = this.getIsUpToDate();\n      this.latestVersionAsString = this.latestVersion?.toFixed(1);\n      this.precheckStatus = this.getPrecheckStatus();\n   }\n\n   /**\n    * Gets the disks versions, it is a simple map, key is vsan formatted version string,\n    * value is the total count of disks which has this version.\n    */\n   private getVersions(): Map<string, number> {\n      const versions: Map<string, number> = new Map<string, number>();\n      // aggregate all host disk versions here.\n      this.diskData.filter(disk => disk.disk.vsanDiskInfo).forEach(disk => {\n         if (DiskMgmtDiskUtil.isHealthy(disk)) {\n            const formatVersion: string = DiskMgmtDiskUtil.getFormatVersion(disk.diskStatus);\n            const count: number = versions.get(formatVersion);\n            if (count) {\n               versions.set(formatVersion, count + 1);\n            } else {\n               versions.set(formatVersion, 1);\n            }\n         }\n      });\n      return versions;\n   }\n\n   getNewInstance(upgradeStatus: VsanUpgradeStatusData): UpgradeData {\n      return new UpgradeData(this.diskData,\n            upgradeStatus, this.hasOldVsanObject, this.latestVersion);\n   }\n\n   private getIsUpToDate(): boolean {\n      if (!this.upgradeDiskData.hasDisks) {\n         // No disks, nothing to check, so assume up to date.\n         return true;\n      }\n      if (this.upgradeDiskData.minVersion >= this.latestVersion &&\n            this.upgradeDiskData.maxVersion >= this.latestVersion &&\n            !this.hasOldVsanObject) {\n         return true;\n      }\n      return false;\n   }\n\n   /**\n    * Gets formatted string for overall upgrade status.\n    */\n   getOverallUpgradeStatus(includeCompatibilityWarning: boolean): string {\n      let statusText: string;\n      if (!this.upgradeDiskData.hasDisks) {\n         // there are no claimed disks\n         return VsanUiUtils.getString(\"vsan.upgrade.manage.no.data\");\n      } else if (this.upgradeDiskData.hasMixedDiskVersions) {\n         // there are disks from different versions, show something like:\n         // 4 of 12 disks on older version\n         statusText = VsanUiUtils.getString(\"vsan.manage.upgrade.mixed.upgradeSuggested\",\n               this.upgradeDiskData.olderNumOfDisks, this.upgradeDiskData.totalNumOfDisks);\n         return this.getUpgradeWithIssuesStatus(statusText, includeCompatibilityWarning);\n      } else if (this.upgradeDiskData.minVersion === this.latestVersion &&\n            this.upgradeDiskData.maxVersion === this.latestVersion) {\n         if (this.hasOldVsanObject) {\n            // the disk format version is latest but there are objects with older version\n            // display something like: \"All 12 disk on 3.0 (latest) but with old VSAN objects\n            statusText = VsanUiUtils.getString(\"vsan.manage.upgrade.latestVersion.oldVsanObjects\",\n                  this.upgradeDiskData.totalNumOfDisks, this.latestVersionAsString);\n            return this.getUpgradeWithIssuesStatus(statusText, includeCompatibilityWarning);\n         } else {\n            // everything is latest, show something like: All 12 disks on 3.0 (latest)\n            return VsanUiUtils.getString(\"vsan.manage.upgrade.latestVersion\",\n                  this.upgradeDiskData.totalNumOfDisks, this.latestVersionAsString);\n         }\n      } else if (this.upgradeDiskData.maxVersion > this.latestVersion) {\n         if (this.hasOldVsanObject) {\n            // the disk format version is latest or higher but there are objects with older version\n            // display something like: \"All 12 disk on 3.0 (latest) or higher but with old VSAN objects\n            statusText = VsanUiUtils.getString(\"vsan.manage.upgrade.latestOrHigherVersion.oldVsanObjects\",\n                  this.upgradeDiskData.totalNumOfDisks, this.latestVersionAsString);\n            return this.getUpgradeWithIssuesStatus(statusText, includeCompatibilityWarning);\n\n         } else {\n            // everything is latest or higher, show something like: All 12 disks on 3.0 (latest) or higher\n            return VsanUiUtils.getString(\"vsan.manage.upgrade.latestOrHigherVersion\",\n                  this.upgradeDiskData.totalNumOfDisks, this.latestVersionAsString);\n         }\n      } else {\n         // all disks are on older versions, show something like:\n         // All 12 disks on 2.0\n         const minVersionAsString: string = (this.upgradeDiskData.minVersion as number).toFixed(1);\n         statusText = VsanUiUtils.getString(\"vsan.manage.upgrade.singleVersion.upgradeSuggested\",\n               this.upgradeDiskData.totalNumOfDisks, minVersionAsString);\n         return this.getUpgradeWithIssuesStatus(statusText, includeCompatibilityWarning);\n      }\n   }\n\n   private getUpgradeWithIssuesStatus(statusText: string, includeCompatibilityWarning: boolean): string {\n      return includeCompatibilityWarning\n            ? VsanUiUtils.getString(\"vsan.manage.upgrade.compatibility.warning\", statusText)\n            : statusText;\n   }\n\n   private getStatus(): VsanUpgradeStatus {\n      if (!this.upgradeStatus) {\n         // it probably means we don't have any information and we can't display anything\n         // about prechecks or actual upgrade\n         return VsanUpgradeStatus.UNKNOWN;\n      }\n\n      // NOTE: at least one of below conditions should be true, maybe here backend\n      // miss one status which is for \"not begin\".\n      if (this.upgradeStatus) {\n         if (this.upgradeStatus.completed) {\n            return VsanUpgradeStatus.COMPLETED;\n         } else if (this.upgradeStatus.aborted) {\n            return VsanUpgradeStatus.ABORTED;\n         } else if (this.upgradeStatus.inProgress) {\n            return VsanUpgradeStatus.IN_PROGRESS;\n         }\n      }\n      return VsanUpgradeStatus.UNKNOWN;\n   }\n\n   private getPrecheckStatus(): string {\n      if (!this.hasPrecheckRunInformation) {\n         // show something like: \"Run pre-check before upgrading.\".\n         return VsanUiUtils.getString(\"vsan.manage.upgrade.precheckSuggested\");\n      } else if (this.status === VsanUpgradeStatus.IN_PROGRESS) {\n         return VsanUiUtils.getString(\"vsan.manage.upgrade.precheckInProgress\");\n      } else {\n         if (this.status === VsanUpgradeStatus.ABORTED) {\n            // show something like: \"Pre-check was aborted.\"\n            return this.getStatusLabelWithTime(\"vsan.manage.upgrade.precheckAborted\");\n         } else if (this.status === VsanUpgradeStatus.COMPLETED) {\n            // prechecks passed successfully\n            if (!this.upgradeStatus.issues || this.upgradeStatus.issues.length === 0) {\n               // No issues, display something like - \"Ready to upgrade - precheck completed\n               // successfully.\"\n               return this.getStatusLabelWithTime(\"vsan.manage.upgrade.precheckCompletedOk\");\n            } else {\n               // Have issues, display something like - \"Pre-check completed with issues.\"\n               return this.getStatusLabelWithTime(\"vsan.manage.upgrade.precheckCompletedWithErrors\");\n            }\n         }\n      }\n   }\n\n   private getStatusLabelWithTime(operationLabelKey: string): string {\n      const operationLabel: string = VsanUiUtils.getString(operationLabelKey);\n      if (!this.upgradeStatus.lastOperationDate) {\n         // There is no timestamp of the operation, append a dot.\n         return operationLabel + \".\";\n      }\n      const lastOperationTime: string = VsanDateTimeUtils.formatDate(this.upgradeStatus.lastOperationDate);\n      return VsanUiUtils.getString(\"vsan.manage.upgrade.precheck.formatWithTime\",\n            operationLabel, lastOperationTime);\n   }\n}\n\nexport enum VsanUpgradeStatus {\n   UNKNOWN = -1,\n   IN_PROGRESS = 0,\n   ABORTED = 1,\n   COMPLETED = 2,\n}\n\nclass UpgradeDisksData {\n   hasDisks: boolean;\n   hasMixedDiskVersions: boolean;\n   minVersionAsString: string;\n   minVersion: number = Number.MAX_VALUE;\n   minVersionKey: string;\n   totalVersionsInCluster: number = 0;\n   maxVersion: number = Number.MIN_VALUE;\n   maxVersionKey: string;\n   totalNumOfDisks: number = 0;\n   olderNumOfDisks: number = 0;\n\n   static create(versions: Map<string, number>, latestVersion: number): UpgradeDisksData {\n      const result: UpgradeDisksData = new UpgradeDisksData();\n      versions.forEach((value, key) => {\n         const versionNum: number = parseInt(key, 10);\n         if (result.minVersion > versionNum) {\n            result.minVersion = versionNum;\n            result.minVersionKey = key;\n         }\n         if (result.maxVersion < versionNum) {\n            result.maxVersion = versionNum;\n            result.maxVersionKey = key;\n         }\n         result.totalNumOfDisks += value;\n         result.olderNumOfDisks += (versionNum < latestVersion)\n               ? value\n               : 0;\n         result.totalVersionsInCluster++;\n      });\n      result.hasDisks = result.totalVersionsInCluster > 0;\n      result.hasMixedDiskVersions = result.totalVersionsInCluster > 1 && result.olderNumOfDisks > 0;\n      result.minVersionAsString = (result.minVersion as number).toFixed(1);\n      return result;\n   }\n}\n","/* Copyright 2020-2021 VMware, Inc. All rights reserved. -- VMware Confidential */\nimport {HostData} from \"@generated/host-data\";\nimport {ConnectionState} from \"@generated/connection-state\";\nimport {VsanUiUtils} from \"@util/vsan-util\";\nimport {VsanCapabilityData} from \"@generated/vsan-capability-data\";\nimport {DiskMgmtDiskGroupUtil} from \"@util/disk-mgmt-disk-group.util\";\nimport {DiskData} from \"@generated/disk-data\";\nimport {ClaimableState} from \"@util/disk-mgmt.util\";\nimport {AvailabilityState} from \"@generated/availability-state\";\nimport {PmemDiskData} from \"@generated/pmem-disk-data\";\n\nexport class DiskMgmtHostUtil {\n   static readonly HEALTHY_MSG_KEY: string = \"vsan.host.healthy\";\n   static readonly UNHEALTHY_MSG_KEY: string = \"vsan.host.unhealthy\";\n   static readonly UNKNOWN_MSG_KEY: string = \"vsan.host.unknown\";\n\n   static getState(host: HostData): string {\n      if (host.state === ConnectionState.notResponding) {\n         return VsanUiUtils.getString(\"vsan.disk.state.notResponding\");\n      }\n      if (host.state === ConnectionState.disconnected) {\n         return VsanUiUtils.getString(\"vsan.disk.state.disconnected\");\n      }\n      if (host.isInMaintenanceMode) {\n         return VsanUiUtils.getString(\"vsan.disk.state.inMaintenanceMode\");\n      }\n      return VsanUiUtils.getString(\"vsan.disk.state.connected\");\n   }\n\n   static getHealthKey(host: HostData): string {\n      for (const group of host.diskGroups) {\n         if (!DiskMgmtDiskGroupUtil.isVsanDiskGroup(group)) {\n            continue;\n         }\n         const groupHealthKey: string = DiskMgmtDiskGroupUtil.getHealthKey(group);\n         if (groupHealthKey !== DiskMgmtDiskGroupUtil.HEALTHY_MSG_KEY) {\n            return groupHealthKey;\n         }\n      }\n\n      switch (host.healthStatus) {\n         case HostData.HealthStatus.HEALTHY:\n            return DiskMgmtHostUtil.HEALTHY_MSG_KEY;\n         case HostData.HealthStatus.UNHEALTHY:\n            return DiskMgmtHostUtil.UNHEALTHY_MSG_KEY;\n         default:\n            return DiskMgmtHostUtil.UNKNOWN_MSG_KEY;\n      }\n   }\n\n   /**\n    * Returns unique group keys of a host, excluding unused group(represented as undefined)\n    */\n   static getGroupTypeKeys = (host: HostData): string[] => {\n      return host.diskGroups\n            .map(group => DiskMgmtDiskGroupUtil.getKey(group))\n            .filter((v, i, a) => v && a.indexOf(v) === i); // removes empty and duplicate keys.\n   };\n\n   static getDataMigrationPrecheckLabel(clusterCapabilities: VsanCapabilityData): string {\n      return clusterCapabilities.isHostResourcePrecheckSupported\n            ? VsanUiUtils.getString(\"vsan.actions.goToPrecheckDataMigration.label\")\n            : VsanUiUtils.getString(\"vsan.actions.precheckDiskGroupEvacuation.label\");\n   }\n\n   static getDisks(host: HostData, claimableState: ClaimableState): DiskData[] {\n      switch (claimableState) {\n         case ClaimableState.IN_USE:\n            return host.disks[AvailabilityState.IN_USE_BY_VSAN]\n                  .concat(host.disks[AvailabilityState.ONLY_MANAGED_BY_VSAN]);\n         case ClaimableState.USABLE:\n            return host.disks[AvailabilityState.ELIGIBLE];\n         case ClaimableState.NOT_USABLE:\n            return host.disks[AvailabilityState.INELIGIBLE];\n      }\n   }\n\n   static getPmemStorage(host: HostData, claimableState: ClaimableState): PmemDiskData[] {\n      switch (claimableState) {\n         case ClaimableState.IN_USE:\n            return host.pmemStorage[AvailabilityState.ONLY_MANAGED_BY_VSAN];\n         case ClaimableState.USABLE:\n            return host.pmemStorage[AvailabilityState.ELIGIBLE];\n         case ClaimableState.NOT_USABLE:\n            return host.pmemStorage[AvailabilityState.INELIGIBLE];\n      }\n   }\n\n   static getClaimDistribution(host: HostData): Map<ClaimableState, number> {\n      const claimDistribution: Map<ClaimableState, number> = new Map<ClaimableState, number>();\n\n      [ClaimableState.IN_USE, ClaimableState.USABLE, ClaimableState.NOT_USABLE].forEach(claimableState =>\n            claimDistribution.set(claimableState, DiskMgmtHostUtil.getDistributionCount(host, claimableState)));\n\n      return claimDistribution;\n   }\n\n   static getClaimedDisksLabel = (host: HostData): string => {\n      const claimDistribution: Map<ClaimableState, number> = DiskMgmtHostUtil.getClaimDistribution(host);\n      return VsanUiUtils.getString(\"vsan.manage.diskManagement.hostList.disksInUse.label\",\n            claimDistribution.get(ClaimableState.IN_USE),\n            claimDistribution.get(ClaimableState.IN_USE) + claimDistribution.get(ClaimableState.USABLE));\n   };\n\n   static orderHostsByHealth(hosts: HostData[]): void {\n      hosts.sort((h1: HostData, h2: HostData) => {\n         return DiskMgmtHostUtil.getHealthKeyOrderPriority(DiskMgmtHostUtil.getHealthKey(h1)) -\n               DiskMgmtHostUtil.getHealthKeyOrderPriority(DiskMgmtHostUtil.getHealthKey(h2));\n      });\n   }\n\n   private static getDistributionCount(host: HostData, claimableState: ClaimableState): number {\n      return DiskMgmtHostUtil.getDisks(host, claimableState).length +\n            DiskMgmtHostUtil.getPmemStorage(host, claimableState).length;\n   }\n\n   private static getHealthKeyOrderPriority(healthKey: string): number {\n      switch (healthKey) {\n         case DiskMgmtHostUtil.UNHEALTHY_MSG_KEY: return 1;\n         case DiskMgmtDiskGroupUtil.LOCKED_MSG_KEY: return 2;\n         case DiskMgmtHostUtil.UNKNOWN_MSG_KEY: return 3;\n         case DiskMgmtDiskGroupUtil.UNMOUNTED_MSG_KEY: return 4;\n         case DiskMgmtHostUtil.HEALTHY_MSG_KEY: return 5;\n         default: return Number.MAX_SAFE_INTEGER;\n      }\n   }\n\n   static getEligibleDiskCount(hostList: HostData[]): number {\n      if (VsanUiUtils.isEmpty(hostList)) {\n         return 0;\n      }\n      return hostList\n            .filter(host => host.state === ConnectionState.connected)\n            .filter(host => !host.isWitnessHost)\n            .reduce((sum, host) => sum +=\n                  DiskMgmtHostUtil.getClaimDistribution(host).get(ClaimableState.USABLE), 0);\n   }\n}","/* Copyright 2021 VMware, Inc. All rights reserved. -- VMware Confidential */\n/**\n * IDs used in external KB link navigation\n */\nexport enum KnowledgeBaseId {\n   PRECHECK_PCP = \"83954\",\n   VIRTUAL_OBJECTS = \"2108319\",\n   UPGRADE = \"2148493\",\n   PERFORMANCE_DIAGNOSTICS = \"2148770\",\n   SUPPORT_INSIGHT = \"60206\",\n}\n","/* Copyright 2020-2021 VMware, Inc. All rights reserved. -- VMware Confidential */\nimport {DiskGroupData} from \"@generated/disk-group-data\";\nimport {VsanUiUtils} from \"@util/vsan-util\";\nimport {DiskGroupType} from \"@generated/disk-group-type\";\nimport {VsanCapabilityData} from \"@generated/vsan-capability-data\";\nimport {DiskMgmtDiskUtil} from \"@util/disk-mgmt-disk.util\";\nimport {StorageGroupData} from \"../../disk-management/views/model/storage-group-data\";\nimport {StorageGroupIdentifier} from \"@component/diskmgmt/model/storage-group-identifier\";\nimport {StorageIdentifier} from \"@component/diskmgmt/model/storage-identifier\";\nimport {DiskData} from \"@generated/disk-data\";\nimport {HostData} from \"@generated/host-data\";\n\nexport class DiskMgmtDiskGroupUtil {\n   static readonly HEALTHY_MSG_KEY: string = \"vsan.host.healthy\";\n   private static readonly UNHEALTHY_MSG_KEY: string = \"vsan.host.unhealthy\";\n   static readonly LOCKED_MSG_KEY: string = \"vsan.host.locked\";\n   static readonly UNMOUNTED_MSG_KEY: string = \"vsan.na.label\";\n\n   static isVsanDiskGroup(diskGroup: DiskGroupData): boolean {\n      return [DiskGroupType.ALL_FLASH, DiskGroupType.HYBRID].includes(diskGroup.diskGroupType);\n   }\n\n   static isAllFlashDiskGroup(diskGroup: DiskGroupData): boolean {\n      return diskGroup.diskGroupType === DiskGroupType.ALL_FLASH;\n   }\n\n   static isVsanDirectDiskGroup(diskGroup: DiskGroupData): boolean {\n      return diskGroup.diskGroupType === DiskGroupType.VSAN_DIRECT;\n   }\n\n   static isPmemDiskGroup(diskGroup: DiskGroupData): boolean {\n      return diskGroup.diskGroupType === DiskGroupType.PMEM;\n   }\n\n   static isVsanMaxSingleTier(diskGroup: DiskGroupData): boolean {\n      return diskGroup.diskGroupType === DiskGroupType.SINGLE_TIER;\n   }\n\n   static isUnusedDiskGroup(storageGroup: StorageGroupData | DiskGroupData): boolean {\n      return storageGroup.diskGroupType === DiskGroupType.UNUSED;\n   }\n\n   static getState(diskGroup: DiskGroupData): string {\n      if (!DiskMgmtDiskGroupUtil.isVsanDiskGroup(diskGroup)) {\n         return \"\";\n      }\n\n      return diskGroup.isMounted\n            ? VsanUiUtils.getString(\"vsan.diskGroup.mounted\")\n            : VsanUiUtils.getString(\"vsan.diskGroup.unmounted\");\n   }\n\n   static getHealthKey(group: DiskGroupData): string {\n      if (!DiskMgmtDiskGroupUtil.isVsanDiskGroup(group)) {\n         return \"\";\n      }\n      if (group.isLocked) {\n         return DiskMgmtDiskGroupUtil.LOCKED_MSG_KEY;\n      }\n      if (!group.isMounted) {\n         return DiskMgmtDiskGroupUtil.UNMOUNTED_MSG_KEY;\n      }\n\n      return group.disks.every(DiskMgmtDiskUtil.isHealthy)\n            ? DiskMgmtDiskGroupUtil.HEALTHY_MSG_KEY\n            : DiskMgmtDiskGroupUtil.UNHEALTHY_MSG_KEY;\n   }\n\n   static getKey(group: DiskGroupData): string {\n      if (DiskMgmtDiskGroupUtil.isVsanDiskGroup(group) || DiskMgmtDiskGroupUtil.isVsanMaxSingleTier(group)) {\n         return DiskGroupKey.VSAN;\n      } else if (DiskMgmtDiskGroupUtil.isVsanDirectDiskGroup(group)) {\n         return DiskGroupKey.VSAN_DIRECT;\n      } else if (DiskMgmtDiskGroupUtil.isPmemDiskGroup(group)) {\n         return DiskGroupKey.PMEM;\n      }\n   }\n\n   static getLabel(diskGroup: DiskGroupData | StorageGroupIdentifier, labelFormat: VsanDiskGroupLabelFormat): string {\n      switch (diskGroup.diskGroupType) {\n         case DiskGroupType.ALL_FLASH:\n         case DiskGroupType.HYBRID:\n            return DiskMgmtDiskGroupUtil.getVsanLabel(diskGroup.name, labelFormat);\n         case DiskGroupType.VSAN_DIRECT:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.vsanDirect\");\n         case DiskGroupType.PMEM:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.pmem\");\n         case DiskGroupType.SINGLE_TIER:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.vsanMax\");\n         case DiskGroupType.UNUSED:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.ineligibleAndUnclaimed\");\n      }\n   }\n\n   static getVsanLabel(uuid: string, labelFormat: VsanDiskGroupLabelFormat): string {\n      switch (labelFormat) {\n         case VsanDiskGroupLabelFormat.TYPE:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.vsan\");\n         case VsanDiskGroupLabelFormat.TYPE_AND_UUID:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.vsan.uuid\", uuid);\n         case VsanDiskGroupLabelFormat.UUID:\n         default:\n            return uuid;\n      }\n   }\n\n   static getType(diskGroup: DiskGroupData): string {\n      switch (diskGroup.diskGroupType) {\n         case DiskGroupType.ALL_FLASH:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.allFlash\");\n         case DiskGroupType.HYBRID:\n            return VsanUiUtils.getString(\"vsan.diskGroup.type.hybrid\");\n         default:\n            return \"\";\n      }\n   }\n\n   static getAggregatedFsVersion(diskGroup: DiskGroupData): string {\n      if (!DiskMgmtDiskGroupUtil.isVsanDiskGroup(diskGroup)) {\n         return \"\";\n      }\n\n      const cacheDisk: DiskData = diskGroup.disks.find(disk => disk.isMappedAsCache);\n      return cacheDisk ? DiskMgmtDiskUtil.getFormatVersion(cacheDisk.diskStatus) : \"\";\n   }\n\n   static getDataMigrationPrecheckLabel(clusterCapabilities: VsanCapabilityData): string {\n      return clusterCapabilities.isDiskResourcePrecheckSupported\n            ? VsanUiUtils.getString(\"vsan.actions.goToPrecheckDataMigration.label\")\n            : VsanUiUtils.getString(\"vsan.actions.precheckDiskGroupEvacuation.label\");\n   }\n\n   static findGroupByStorage(diskGroups: DiskGroupData[], storage: StorageIdentifier): DiskGroupData {\n      return diskGroups.find(group =>\n            (group.disks && group.disks.some(disk => StorageIdentifier.areEqual(disk, storage))) ||\n            (group.pmemStorage && group.pmemStorage.some(disk => StorageIdentifier.areEqual(disk, storage))));\n   }\n\n   static getBreadcrumbPreselectedDiskGroup = (host: HostData): DiskGroupData | null => {\n      return host?.isSingleTierEnabled ? host.diskGroups[0] : null;\n   };\n}\n\nexport enum DiskGroupKey {\n   VSAN = \"vsan.manage.diskManagement.hostList.contributesTo.label.vsan\",\n   VSAN_DIRECT = \"vsan.manage.diskManagement.hostList.contributesTo.label.vsanDirect\",\n   PMEM = \"vsan.manage.diskManagement.hostList.contributesTo.label.pmem\",\n}\n\nexport enum VsanDiskGroupLabelFormat {\n   TYPE, UUID, TYPE_AND_UUID,\n}","/* Copyright 2020-2022 VMware, Inc. All rights reserved. -- VMware Confidential */\nimport {Injectable} from \"@angular/core\";\nimport {UpgradeData} from \"@component/upgrade/upgrade.data\";\nimport {DiskData} from \"@generated/disk-data\";\nimport {DiskManagementService} from \"@generated/disk-management-service\";\nimport {HostData} from \"@generated/host-data\";\nimport {VsanUpgradeMutationProvider} from \"@generated/vsan-upgrade-mutation-provider\";\nimport {VsanUpgradePropertyProvider} from \"@generated/vsan-upgrade-property-provider\";\nimport {VsanUpgradeStatusData} from \"@generated/vsan-upgrade-status-data\";\nimport {ManagedObject} from \"@service/managed-object\";\nimport {DiskMgmtHostUtil} from \"@util/disk-mgmt-host.util\";\nimport {ClaimableState} from \"@util/disk-mgmt.util\";\nimport {VsanUiUtils} from \"@util/vsan-util\";\n\n/**\n * Provides data for disks and objects format version.\n */\n@Injectable()\nexport class UpgradeService {\n\n   constructor(private upgradePropertyProvider: VsanUpgradePropertyProvider,\n         private upgradeMutationProvider: VsanUpgradeMutationProvider,\n         private diskMgmtService: DiskManagementService) {\n   }\n\n   getUpgradeData(clusterRef: ManagedObject): Promise<UpgradeData> {\n      return new Promise<UpgradeData>((accept, reject) => {\n         this.diskMgmtService.listHosts(clusterRef).then((hostDisksData: HostData[]) => {\n            accept(this.getUpgradeOnlyData(clusterRef, hostDisksData));\n         }).catch(error => reject(error));\n      });\n   }\n\n   async getUpgradeOnlyData(clusterRef: ManagedObject, hostDisks: HostData[]): Promise<UpgradeData> {\n      const claimedDisks: DiskData[] = this.getClaimedDisks(hostDisks);\n\n      if (VsanUiUtils.isEmpty(claimedDisks)) {\n         // No disks claimed, no need to query upgrade status\n         return new UpgradeData(claimedDisks, null, null, null);\n      }\n\n      let upgradeStatusData: VsanUpgradeStatusData;\n      let hasOldVsanObject: boolean;\n      let latestVersion: number;\n\n      [upgradeStatusData, hasOldVsanObject, latestVersion] = await Promise.all([\n         this.getUpgradeStatus(clusterRef),\n         this.hasOldFormatObjects(clusterRef),\n         this.getLatestVsanVersion(clusterRef),\n      ]);\n      return new UpgradeData(claimedDisks, upgradeStatusData, hasOldVsanObject, latestVersion);\n   }\n\n   getUpgradeStatus(clusterRef: ManagedObject): Promise<VsanUpgradeStatusData> {\n      return this.upgradePropertyProvider.getVsanUpgradeStatus(clusterRef);\n   }\n\n   hasOldFormatObjects(clusterRef: ManagedObject): Promise<boolean> {\n      return this.upgradePropertyProvider.getHasOldVsanObject(clusterRef);\n   }\n\n   getLatestVsanVersion(clusterRef: ManagedObject): Promise<number> {\n      return this.upgradePropertyProvider.getLatestVsanVersion(clusterRef);\n   }\n\n   isUpgradeNeeded(upgradeData: UpgradeData): boolean {\n      if (upgradeData.upgradeDiskData.hasMixedDiskVersions) {\n         // there are older disks\n         return true;\n      } else if (upgradeData.upgradeDiskData.minVersion >= upgradeData.latestVersion) {\n         // disks are at latest version, check for old objects\n         return upgradeData.hasOldVsanObject;\n      }\n\n      // All disks are on older versions\n      return true;\n   }\n\n   precheckUpgrade(contextObject: ManagedObject): Promise<ManagedObject> {\n      return this.upgradeMutationProvider.performUpgradePreflightAsyncCheck(contextObject);\n   }\n\n   private getClaimedDisks(hostDisksData: HostData[]): DiskData[] {\n      let disks: DiskData[] = [];\n      hostDisksData.forEach(host => {\n         disks = disks.concat(DiskMgmtHostUtil.getDisks(host, ClaimableState.IN_USE));\n      });\n      return disks;\n   }\n}\n","/* Copyright 2020-2021 VMware, Inc. All rights reserved. -- VMware Confidential */\n/**\n * uuid is required for identification. Name is required for screen reader\n */\nexport class StorageIdentifier {\n   constructor(public uuid: string, public name: string) {\n   }\n   static areEqual(value1: StorageIdentifier, value2: StorageIdentifier): boolean {\n      return value1 && value2 && (value1.uuid === value2.uuid);\n   }\n}"]}